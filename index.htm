<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>DSA Charakterbogen — 3D Dice (Static)</title>
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
<style>
body { font-family:sans-serif; margin:20px; }
input, button { margin:6px; }
.log { margin-top:20px; padding:10px; border:1px solid #ccc; max-height:200px; overflow-y:auto; background:#f9f9f9; }
.log-entry { border-bottom:1px solid #ddd; padding:6px 0; }
.dice-row { display:flex; flex-wrap:wrap; gap:12px; margin-top:10px; }
.dice-wrapper { width:90px; height:90px; }
.controls { margin-top:8px; }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">

const { useState, useEffect, useRef } = React;
const ATTRS = ["MU","KL","IN","CH","FF","GE","KO","KK"];

/***************************
 * ThreeD20 Static component
 ***************************/
function ThreeD20({ value, size=90 }) {
  const mountRef = useRef();

  useEffect(()=>{
    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#f6f6f6");
    const camera = new THREE.PerspectiveCamera(45,1,0.1,1000);
    camera.position.set(0,0,6);
    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(size,size);
    mountRef.current.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff,0.8);
    light.position.set(5,10,7);
    scene.add(light);

    const geom = new THREE.IcosahedronGeometry(2,0);
    const mat = new THREE.MeshStandardMaterial({color:"#1f6feb", flatShading:true});
    const mesh = new THREE.Mesh(geom,mat);
    scene.add(mesh);

    // Create number sprite
    const posAttr = geom.attributes.position;
    const indexArr = geom.index.array;
    const faceNumber = Math.min(Math.max(1,value||1),20);
    const f = faceNumber-1;
    const iA=indexArr[3*f], iB=indexArr[3*f+1], iC=indexArr[3*f+2];
    const a=new THREE.Vector3().fromBufferAttribute(posAttr,iA);
    const b=new THREE.Vector3().fromBufferAttribute(posAttr,iB);
    const c=new THREE.Vector3().fromBufferAttribute(posAttr,iC);
    const centroid=new THREE.Vector3().addVectors(a,b).add(c).multiplyScalar(1/3);
    const canvas=document.createElement("canvas"); canvas.width=128; canvas.height=128;
    const ctx=canvas.getContext("2d");
    ctx.fillStyle="rgba(255,255,255,0.95)"; ctx.beginPath(); ctx.arc(64,64,48,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="#111"; ctx.font="bold 56px sans-serif"; ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(String(faceNumber),64,64);
    const tex=new THREE.CanvasTexture(canvas); tex.needsUpdate=true;
    const sprMat = new THREE.SpriteMaterial({map:tex, depthTest:false});
    const sprite = new THREE.Sprite(sprMat);
    sprite.position.copy(centroid.clone().multiplyScalar(1.08));
    sprite.scale.set(0.45,0.45,0.45);
    scene.add(sprite);

    function animate(){
      mesh.rotation.x+=0.005;
      mesh.rotation.y+=0.01;
      sprite.lookAt(camera.position);
      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }
    animate();

    return ()=>{ mountRef.current.removeChild(renderer.domElement); };

  },[value,size]);

  return <div ref={mountRef} style={{width:size,height:size}} />;
}

/***************************
 * Full App
 ***************************/
function App(){
  const [characters,setCharacters]=useState({});
  const [currentChar,setCurrentChar]=useState(null);
  const [skills,setSkills]=useState([]);
  const [manualMode,setManualMode]=useState(false);
  const [log,setLog]=useState([]);
  const [diceResults,setDiceResults]=useState([]);
  const [manualModalVisible,setManualModalVisible]=useState(false);
  const [manualSkill,setManualSkill]=useState(null);
  const [manualUseSpec,setManualUseSpec]=useState(false);
  const [manualRolls,setManualRolls]=useState(["","",""]);

  useEffect(()=>{
    const saved=localStorage.getItem("dsa_characters");
    if(saved){ const parsed=JSON.parse(saved); setCharacters(parsed); const first=Object.keys(parsed)[0]; if(first){ setCurrentChar(first); setSkills(parsed[first].skills||[]); } }
  },[]);

  function saveChars(newChars){ setCharacters(newChars); localStorage.setItem("dsa_characters",JSON.stringify(newChars)); }
  function newCharacter(){ const name=prompt("Neuer Charaktername:"); if(!name)return; if(characters[name]){alert("Name existiert bereits!"); return;} const attrs={}; ATTRS.forEach(a=>attrs[a]=12); const newChars={...characters,[name]:{attributes:attrs,skills:[]}}; setCurrentChar(name); setSkills([]); saveChars(newChars); }
  function deleteCharacter(){ if(!currentChar)return; if(!confirm(`Charakter "${currentChar}" wirklich löschen?`))return; const newChars={...characters}; delete newChars[currentChar]; const first=Object.keys(newChars)[0]||null; setCurrentChar(first); setSkills(first?newChars[first].skills:[]); saveChars(newChars);}
  function updateAttr(attr,value){ const updated={...characters,[currentChar]:{...characters[currentChar],attributes:{...characters[currentChar].attributes,[attr]:parseInt(value)||0}}}; saveChars(updated);}
  function addSkill(){ const name=prompt("Talentname:"); if(!name)return; const attrStr=prompt("Attribute (z.B. MU,KL,IN)"); if(!attrStr)return; const attrs=attrStr.split(",").map(a=>a.trim()); const taw=parseInt(prompt("TaW:")||"0",10); const spec=prompt("Spezialisierung (optional)"); const newSkill={name,attr:attrs,value:taw,spec}; const newSkills=[...skills,newSkill]; setSkills(newSkills); const updated={...characters,[currentChar]:{...characters[currentChar],skills:newSkills}}; saveChars(updated);}
  function clearSkills(){ if(!confirm("Alle Talente löschen?"))return; setSkills([]); const updated={...characters,[currentChar]:{...characters[currentChar],skills:[]}}; saveChars(updated);}
  function rollD20(){return Math.floor(Math.random()*20)+1;}
  function qualityLevel(tap){if(tap<1)return 0;if(tap<=3)return 1;if(tap<=6)return 2;if(tap<=9)return 3;if(tap<=12)return 4;if(tap<=15)return 5;return 6;}
  function addToLog(entry){ setLog(prev=>[entry,...prev]); }

  function processRoll(skill,useSpec,rolls,attrs){
    const ones=rolls.filter(r=>r===1).length;
    const twenties=rolls.filter(r=>r===20).length;
    if(ones>=2){ addToLog({skill:skill.name,rolls,result:"✅ Kritischer Erfolg",tap:skill.value,qs:qualityLevel(skill.value)}); return; }
    if(twenties>=2){ addToLog({skill:skill.name,rolls,result:"❌ Kritischer Patzer"}); return; }
    let taw=skill.value+(useSpec&&skill.spec?2:0); let success=true;
    skill.attr.forEach((a,i)=>{ const roll=rolls[i]; const attrVal=attrs[a]||0; const diff=roll-attrVal; if(diff>0){taw-=diff;if(taw<0)success=false;} });
    let tap=success?taw:-1; let qs=success?qualityLevel(tap):0;
    addToLog({skill:skill.name+(useSpec&&skill.spec?" (Spez)":""),rolls,result:success?`✅ Erfolg (TaP*: ${tap}, QS: ${qs})`:"❌ Misslungen"});
  }

  function rollSkill(skill,useSpec){
    const attrs=characters[currentChar].attributes;
    if(manualMode){ setManualSkill(skill); setManualUseSpec(useSpec); setManualRolls(["","",""]); setManualModalVisible(true);}
    else{
      const rolls=skill.attr.map(()=>rollD20());
      setDiceResults(rolls.slice());
      processRoll(skill,useSpec,rolls,attrs);
    }
  }

  function exportAll(){ const blob=new Blob([JSON.stringify(characters,null,2)],{type:"application/json"}); const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="dsa_characters.json"; a.click(); URL.revokeObjectURL(url);}
  function importJSON(e){ const file=e.target.files[0]; if(!file)return; const reader=new FileReader(); reader.onload=ev=>{ try{ const data=JSON.parse(ev.target.result); if(data.name&&data.attributes){ const newChars={...characters,[data.name]:{attributes:data.attributes,skills:data.skills||[]}}; setCurrentChar(data.name); setSkills(data.skills||[]); saveChars(newChars);} else {setCharacters(data); const first=Object.keys(data)[0]; setCurrentChar(first); setSkills(first?data[first].skills:[]); saveChars(data);} alert("Import erfolgreich!"); }catch(err){alert("Fehler: Ungültige JSON-Datei");}}; reader.readAsText(file);}
  function confirmManualRoll(){ const rolls=manualRolls.map(r=>parseInt(r,10)); if(rolls.some(x=>isNaN(x))){alert("Bitte drei gültige Zahlen eingeben!");return;} setDiceResults(rolls.slice()); processRoll(manualSkill,manualUseSpec,rolls,characters[currentChar].attributes); setManualModalVisible(false); }

  if(!currentChar){ return <div><button onClick={newCharacter}>Neuer Charakter</button></div>; }

  return (
    <div>
      <h2>Charakter: {currentChar}</h2>
      <div className="controls">
        <button onClick={newCharacter}>+ Neu</button>
        <button onClick={deleteCharacter}>Löschen</button>
      </div>

      <h3>Eigenschaften</h3>
      {ATTRS.map(a=>(
        <div key={a}>{a}: <input type="number" value={characters[currentChar].attributes[a]||0} onChange={e=>updateAttr(a,e.target.value)} style={{width:60}} /></div>
      ))}

      <h3>Talente</h3>
      <ul>
        {skills.map((item,idx)=>(
          <li key={idx}>
            <strong>{item.name}</strong> [{item.attr.join("/")}] TaW {item.value} {item.spec?( `(Spez: ${item.spec})`):""}
            <div style={{marginTop:6}}>
              <button onClick={()=>rollSkill(item,false)}>Würfeln</button>
              {item.spec && <button onClick={()=>rollSkill(item,true)}>Würfeln (Spez)</button>}
            </div>
          </li>
        ))}
      </ul>
      <div className="controls">
        <button onClick={addSkill}>+ Talent hinzufügen</button>
        <button onClick={clearSkills}>Talente löschen</button>
      </div>

      <h3>Würfelmodus</h3>
      <button onClick={()=>setManualMode(!manualMode)}>
        {manualMode?"🎲 Manueller Modus (aktiv)":"🎲 Automatischer Modus (aktiv)"}
      </button>

      <h3>Import / Export</h3>
      <button onClick={exportAll}>Exportieren</button>
      <input type="file" accept="application/json" onChange={importJSON} />

      <h3>Letzte Würfel</h3>
      <div className="dice-row">
        {diceResults.length===0 && <div>Keine Würfe bisher</div>}
        {diceResults.map((v,i)=>(
          <div key={i} className="dice-wrapper">
            <ThreeD20 value={v} />
          </div>
        ))}
      </div>

      <h3>Würfellog</h3>
      <div className="log">
        {log.length===0 && <div>Noch keine Würfe</div>}
        {log.map((entry,idx)=>(
          <div key={idx} className="log-entry">
            <strong>{entry.skill}</strong> – Würfe: {entry.rolls.join(", ")}<br/>
            Ergebnis: {entry.result}
          </div>
        ))}
      </div>

      {manualModalVisible && (
        <div className="modal">
          <div className="modal-content">
            <h3>Würfelwerte für {manualSkill?.name}</h3>
            {manualSkill?.attr.map((a,idx)=>(
              <div key={idx}>{a}: <input type="number" value={manualRolls[idx]} onChange={e=>{ const nr=[...manualRolls]; nr[idx]=e.target.value; setManualRolls(nr); }} /></div>
            ))}
            <div style={{marginTop:8, display:"flex", justifyContent:"space-between"}}>
              <button onClick={()=>setManualModalVisible(false)}>Abbrechen</button>
              <button onClick={confirmManualRoll}>OK</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
</body>
</html>
