<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <title>DSA Charakterbogen</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
      }
      input, button {
        margin: 4px;
      }
      .modal {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(0,0,0,0.5);
        display: flex; justify-content: center; align-items: center;
      }
      .modal-content {
        background: white; padding: 20px; border-radius: 10px;
      }
      .log {
        margin-top: 20px; padding: 10px; border: 1px solid #ccc;
        max-height: 200px; overflow-y: auto; background: #f9f9f9;
      }
      .log-entry {
        border-bottom: 1px solid #ddd;
        padding: 5px 0;
      }
      .dice-container {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }
      .dice {
        width: 50px; height: 50px;
        border-radius: 50%;
        background: #eee;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 20px;
        border: 2px solid #333;
        animation: roll 1s ease-in-out;
      }
      @keyframes roll {
        0% { transform: rotate(0deg); }
        25% { transform: rotate(90deg); }
        50% { transform: rotate(180deg); }
        75% { transform: rotate(270deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect } = React;
      const ATTRS = ["MU","KL","IN","CH","FF","GE","KO","KK"];

      function DiceRoll({ finalValue }) {
        const [display, setDisplay] = useState("?");
        useEffect(() => {
          let i = 0;
          const interval = setInterval(() => {
            setDisplay(Math.floor(Math.random() * 20) + 1);
            i++;
            if (i > 10) { // ~1s then stop
              clearInterval(interval);
              setDisplay(finalValue);
            }
          }, 100);
          return () => clearInterval(interval);
        }, [finalValue]);
        return <div className="dice">{display}</div>;
      }

      function App() {
        const [characters, setCharacters] = useState({});
        const [currentChar, setCurrentChar] = useState(null);
        const [skills, setSkills] = useState([]);
        const [manualMode, setManualMode] = useState(false);

        const [manualModalVisible, setManualModalVisible] = useState(false);
        const [manualSkill, setManualSkill] = useState(null);
        const [manualUseSpec, setManualUseSpec] = useState(false);
        const [manualRolls, setManualRolls] = useState(["","",""]);

        const [log, setLog] = useState([]);
        const [diceResults, setDiceResults] = useState([]); // store last dice animation results

        useEffect(() => {
          const saved = localStorage.getItem("dsa_characters");
          if (saved) {
            const parsed = JSON.parse(saved);
            setCharacters(parsed);
            const first = Object.keys(parsed)[0];
            if (first) {
              setCurrentChar(first);
              setSkills(parsed[first].skills || []);
            }
          }
        }, []);

        function saveCharacters(newChars) {
          setCharacters(newChars);
          localStorage.setItem("dsa_characters", JSON.stringify(newChars));
        }

        function newCharacter() {
          const name = prompt("Neuer Charaktername:");
          if (!name) return;
          if (characters[name]) { alert("Name existiert bereits!"); return; }
          const attrs = {}; ATTRS.forEach(a => attrs[a] = 12);
          const newChars = { ...characters, [name]: { attributes: attrs, skills: [] } };
          setCurrentChar(name); setSkills([]); saveCharacters(newChars);
        }

        function deleteCharacter() {
          if (!currentChar) return;
          if (!window.confirm(`Charakter "${currentChar}" wirklich löschen?`)) return;
          const newChars = { ...characters }; delete newChars[currentChar];
          const first = Object.keys(newChars)[0] || null;
          setCurrentChar(first); setSkills(first ? newChars[first].skills : []);
          saveCharacters(newChars);
        }

        function updateAttr(attr, value) {
          const updated = { ...characters,
            [currentChar]: {
              ...characters[currentChar],
              attributes: { ...characters[currentChar].attributes, [attr]: parseInt(value)||0 }
            }
          };
          saveCharacters(updated);
        }

        function addSkill() {
          const name = prompt("Talentname:"); if (!name) return;
          const attrStr = prompt("Attribute (z.B. MU,KL,IN):"); if (!attrStr) return;
          const attrs = attrStr.split(",").map(a=>a.trim());
          const taw = parseInt(prompt("TaW:")||"0",10);
          const spec = prompt("Spezialisierung (optional):");
          const newSkill = { name, attr: attrs, value: taw, spec };
          const newSkills = [...skills,newSkill]; setSkills(newSkills);
          const updated = { ...characters,
            [currentChar]: { ...characters[currentChar], skills: newSkills } };
          saveCharacters(updated);
        }

        function clearSkills() {
          if (!window.confirm("Alle Talente löschen?")) return;
          setSkills([]); 
          const updated = { ...characters,
            [currentChar]: { ...characters[currentChar], skills: [] } };
          saveCharacters(updated);
        }

        function rollD20() { return Math.floor(Math.random()*20)+1; }

        function qualityLevel(tap) {
          if (tap<1) return 0; if (tap<=3) return 1; if (tap<=6) return 2;
          if (tap<=9) return 3; if (tap<=12) return 4; if (tap<=15) return 5; return 6;
        }

        function rollSkill(skill,useSpec) {
          const attrs = characters[currentChar].attributes;
          if (manualMode) {
            setManualSkill(skill); setManualUseSpec(useSpec); setManualRolls(["","",""]);
            setManualModalVisible(true);
          } else {
            const rolls = skill.attr.map(()=>rollD20());
            setDiceResults(rolls); // trigger dice animations
            processRoll(skill,useSpec,rolls,attrs);
          }
        }

        function addToLog(entry) { setLog(prev=>[entry,...prev]); }

        function processRoll(skill,useSpec,rolls,attrs) {
          const ones = rolls.filter(r=>r===1).length;
          const twenties = rolls.filter(r=>r===20).length;

          if (ones>=2) {
            addToLog({ skill: skill.name, rolls, result: "✅ Kritischer Erfolg", tap: skill.value, qs: qualityLevel(skill.value) });
            return;
          }
          if (twenties>=2) {
            addToLog({ skill: skill.name, rolls, result: "❌ Kritischer Patzer" });
            return;
          }

          let taw = skill.value + (useSpec && skill.spec ? 2 : 0);
          let success = true;
          skill.attr.forEach((a,i)=> {
            const roll = rolls[i]; const attrVal = attrs[a]||0;
            let diff = roll-attrVal;
            if (diff>0) { taw -= diff; if (taw<0) success=false; }
          });
          let tap = success ? taw : -1;
          let qs = success ? qualityLevel(tap) : 0;

          addToLog({
            skill: skill.name+(useSpec && skill.spec ? " (Spez)" : ""),
            rolls,
            result: success ? `✅ Erfolg (TaP*: ${tap}, QS: ${qs})` : "❌ Misslungen"
          });
        }

        function exportAll() {
          const blob=new Blob([JSON.stringify(characters,null,2)],{type:"application/json"});
          const url=URL.createObjectURL(blob); const a=document.createElement("a");
          a.href=url; a.download="dsa_characters.json"; a.click(); URL.revokeObjectURL(url);
        }

        function importJSON(event) {
          const file=event.target.files[0]; if(!file) return;
          const reader=new FileReader();
          reader.onload=e=>{
            try {
              const data=JSON.parse(e.target.result);
              if(data.name&&data.attributes) {
                const newChars={...characters,[data.name]:{attributes:data.attributes,skills:data.skills||[]}};
                setCurrentChar(data.name); setSkills(data.skills||[]); saveCharacters(newChars);
              } else {
                setCharacters(data); const first=Object.keys(data)[0];
                setCurrentChar(first); setSkills(first?data[first].skills:[]); saveCharacters(data);
              }
              alert("Import erfolgreich!");
            } catch(err){ alert("Fehler: Ungültige JSON-Datei"); }
          };
          reader.readAsText(file);
        }

        function confirmManualRoll() {
          const rolls=manualRolls.map(r=>parseInt(r,10));
          if(rolls.some(x=>isNaN(x))) { alert("Bitte drei gültige Zahlen eingeben!"); return; }
          setDiceResults(rolls); // show dice animations
          processRoll(manualSkill,manualUseSpec,rolls,characters[currentChar].attributes);
          setManualModalVisible(false);
        }

        if(!currentChar){
          return <div><button onClick={newCharacter}>Neuer Charakter</button></div>;
        }

        return (
          <div>
            <h2>Charakter: {currentChar}</h2>
            <button onClick={newCharacter}>+ Neu</button>
            <button onClick={deleteCharacter}>Löschen</button>

            <h3>Eigenschaften</h3>
            {ATTRS.map(a=>(
              <div key={a}>
                {a}: <input type="number"
                  value={characters[currentChar].attributes[a]||0}
                  onChange={e=>updateAttr(a,e.target.value)}
                  style={{width:50}} />
              </div>
            ))}

            <h3>Talente</h3>
            <ul>
              {skills.map((item,idx)=>(
                <li key={idx}>
                  {item.name} [{item.attr.join("/")}] TaW {item.value} {item.spec?`(Spez: ${item.spec})`:""}
                  <div>
                    <button onClick={()=>rollSkill(item,false)}>Würfeln</button>
                    {item.spec && <button onClick={()=>rollSkill(item,true)}>Würfeln (Spez)</button>}
                  </div>
                </li>
              ))}
            </ul>
            <button onClick={addSkill}>+ Talent hinzufügen</button>
            <button onClick={clearSkills}>Talente löschen</button>

            <h3>Würfelmodus</h3>
            <button onClick={()=>setManualMode(!manualMode)}>
              {manualMode ? "🎲 Manueller Modus (aktiv)" : "🎲 Automatischer Modus (aktiv)"}
            </button>

            <h3>Import / Export</h3>
            <button onClick={exportAll}>Exportieren</button>
            <input type="file" accept="application/json" onChange={importJSON}/>

            <h3>Letzte Würfel</h3>
            <div className="dice-container">
              {diceResults.map((val,idx)=><DiceRoll key={idx} finalValue={val} />)}
            </div>

            <h3>Würfellog</h3>
            <div className="log">
              {log.length===0 && <div>Noch keine Würfe</div>}
              {log.map((entry,idx)=>(
                <div key={idx} className="log-entry">
                  <strong>{entry.skill}</strong> – Würfe: {entry.rolls.join(", ")}<br/>
                  Ergebnis: {entry.result}
                </div>
              ))}
            </div>

            {manualModalVisible && (
              <div className="modal">
                <div className="modal-content">
                  <h3>Würfelwerte für {manualSkill?.name}</h3>
                  {manualSkill?.attr.map((a,idx)=>(
                    <div key={idx}>
                      {a}: <input type="number"
                        value={manualRolls[idx]}
                        onChange={e=>{
                          const newRolls=[...manualRolls]; newRolls[idx]=e.target.value; setManualRolls(newRolls);
                        }} />
                    </div>
                  ))}
                  <button onClick={()=>setManualModalVisible(false)}>Abbrechen</button>
                  <button onClick={confirmManualRoll}>OK</button>
                </div>
              </div>
            )}
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
    </script>
  </body>
</html>
